#!/usr/bin/env ruby
# frozen_string_literal: true

require 'erb'
require 'json'
require 'net/http'
require 'uri'
require 'git' # Non-stdlib
require 'graphql/client' # Non-stdlib
require 'graphql/client/http' # Non-stdlib

def find(object, key, values = [])
  return values unless object.is_a?(Hash) || object.is_a?(Array)

  values << object[key] if object.is_a?(Hash) && object[key]

  enumerator = object.is_a?(Hash) ? object.each_value : object.each

  enumerator.each do |value|
    find(value, key, values)
  end

  values
end

API_KEY = JSON.parse(File.read("#{Dir.home}/.config/creds.json"))['GITHUB_API_KEY']

module GithubAPI
  HTTP = GraphQL::Client::HTTP.new('https://api.github.com/graphql') do
    def headers(_context)
      { 'Authorization' => "bearer #{API_KEY}" }
    end
  end

  # Schema = GraphQL::Client.load_schema(HTTP)
  Schema = GraphQL::Client.load_schema('/Users/ndthp/github_schema_c.json')

  Client = GraphQL::Client.new(schema: Schema, execute: HTTP)
end

ClosestPRQuery = GithubAPI::Client.parse <<-'GRAPHQL'
  query($owner: String!, $name: String!, $hash: String) {
     repository(owner: $owner, name: $name) {
       item: object(expression: $hash) {
         ... on Commit {
           associatedPullRequests(first: 5) {
             nodes {
               url
             }
           }
         }
       }
     }
    }
GRAPHQL

result = GithubAPI::Client.query(ClosestPRQuery)

puts result.data
puts result.errors.to_a

# # Simple class to use Github V4 graphql api
# # It's BYOQ (Bring your own query)
# class GithubGQL
#   BASE_URI = URI.parse('https://api.github.com/graphql')
#   attr_reader :owner, :repo_name, :hash, :hashes

#   def initialize(api_key = api_from_config, argv = ARGV)
#     @api_key = api_key
#     @git = Git.open('.')
#     @owner, @repo_name = parse_github_remote_info

#     rev_parse_args = argv.empty? ? 'HEAD' : argv
#     @hashes = @git.revparse(rev_parse_args).split("\n")
#     @hash = hashes.first
#   end

#   def self.request(query_template)
#     GithubGQL.new.request(query_template)
#   end

#   def request(query_template)
#     request = Net::HTTP::Post.new(BASE_URI)
#     request['Authorization'] = "bearer #{@api_key}"
#     request.body = JSON.dump(query: ERB.new(query_template).result(binding))

#     hostname = BASE_URI.hostname
#     port = BASE_URI.port
#     response = Net::HTTP.start(hostname, port, use_ssl: true) do |http|
#       http.request(request)
#     end

#     JSON.parse(response.body)
#   end

#   private

#   def api_from_config
#     JSON.parse(File.read("#{Dir.home}/.config/creds.json"))['GITHUB_API_KEY']
#   end

#   def parse_github_remote_info
#     re = %r{(git@github.com:|https://github.com/)(?<owner>.+)/(?<repo_name>.+)$}
#     remote = @git.config('remote.origin.url')
#                  .match(re)

#     raise 'Could not parse remote information!' if remote.nil?

#     [remote[:owner], remote[:repo_name]]
#   end
# end

# def closest_pr
#   query = <<~HEREDOC
#     {
#      repository(owner: "<%= owner %>", name: "<%= repo_name %>") {
#      <% hashes.each.with_index do |h, i| %>
#        _<%= i %>: object(expression: "<%= h %>") {
#          ... on Commit {
#            associatedPullRequests(first: 5) {
#              nodes {
#                url
#              }
#            }
#          }
#        }
#      <% end %>
#      }
#     }
#   HEREDOC

#   parsed_response = GithubGQL
#                     .request(query)
#   urls = find(parsed_response, 'url').compact.sort.uniq

#   if urls.size == 1 && urls.first && urls.first != 'null'
#     system("open #{urls.first}")
#   elsif urls.size > 1
#     puts urls
#   else
#     exit 1
#   end
# end

# def git_ci
#   query = <<~HEREDOC
#     {
#       repository(owner: "<%= owner %>", name: "<%= repo_name %>") {
#         object(expression: "<%= hash %>") {
#           ... on Commit {
#             status {
#               state
#               contexts {
#                 state
#                 targetUrl
#               }
#             }
#           }
#         }
#       }
#     }
#   HEREDOC

#   parsed_response = GithubGQL
#                     .request(query)
#   state = find(parsed_response, 'state').first
#   url = find(parsed_response, 'url').first

#   if state == 'PENDING'
#     puts 'pending!'
#     exit
#   end

#   if url && url != 'null'
#     system("open #{url}")
#   else
#     exit 1
#   end
# end

# closest_pr
# # git_ci
